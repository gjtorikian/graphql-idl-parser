use type_definition::*;

grammar;

// TODO: missing others types
pub schema: Vec<TypeDefinition> =
    <TypeDefinition*> => <>;

TypeDefinition: TypeDefinition = {
    ScalarTypeDefinition,
    ObjectTypeDefinition,
    EnumTypeDefinition,
    InterfaceTypeDefinition,
    UnionTypeDefinition,
    InputObjectTypeDefinition,
};

ScalarTypeDefinition: TypeDefinition = {
    <d:Description*> "scalar" <n:Name> => {
        TypeDefinition::ScalarType(GraphQLScalar::new(d, n))
    }
};

// TODO: missing directives
ObjectTypeDefinition: TypeDefinition = {
    <d:Description*> "type" <n:Name> <i:(ImplementsInterfaces?)> "{" <f:(<FieldDefinition>)*> "}" => {
        TypeDefinition::ObjectType(GraphQLObject::new(d, n, i, f))
    },
};

// TODO: missing directives
EnumTypeDefinition: TypeDefinition = {
    <d:Description*> "enum" <n:Name> "{" <f:(<EnumValueDefinition>)+> "}" => {
        TypeDefinition::EnumType(GraphQLEnum::new(d, n, f))
    }
};

// TODO: missing directives
InterfaceTypeDefinition: TypeDefinition = {
    <d:Description*> "interface" <n:Name> "{" <f:(<FieldDefinition>)*> "}" => {
        TypeDefinition::InterfaceType(GraphQLInterface::new(d, n, f))
    },

};

// TODO: missing directives
UnionTypeDefinition: TypeDefinition = {
    <d:Description*> "union" <n:Name> "=" <t:Pipe<Name>> => {
        TypeDefinition::UnionType(GraphQLUnion::new(d, n, t))
    }
};

// TODO: missing directives
InputObjectTypeDefinition: TypeDefinition = {
    <d:Description*> "input" <n:Name> "{" <f:(<FieldDefinition>)*> "}" => {
        TypeDefinition::InputObjectType(GraphQLInputObject::new(d, n, f))
    },
};

ImplementsInterfaces: Vec<String> = {
    "implements" <i:Comma<Name>> => {
        i
    }
};

// TODO: missing directives
FieldDefinition: GraphQLField = {
    <d:Description*> <n:FieldName> <a:(ArgumentsDefinition?)> ":" <t:FieldType> <e:Deprecated?> <r:DeprecatedReason?> => {
        GraphQLField::new(d, n, t, a, check_deprecated(e), r)
    },
};

// TODO: missing directives
EnumValueDefinition: GraphQLValue = {
    <d:Description*> <n:Name> => {
        GraphQLValue::new(d, n)
    }
};

FieldType: FieldType = {
    <n:Name> <r:"!"?> => {
        FieldType {
            name: n,
            info: match r {
              None => TypeInfo::Nullable,
              Some(r) => TypeInfo::NonNullable,
            }
        }
    },
    "[" <n:Name> <r:"!"?> "]" <l:"!"?> => {
        FieldType {
            name: n,
            info: match r {
              None => match l {
                  None => TypeInfo::NullableListNullableElements,
                  Some(l) => TypeInfo::NonNullableListNullableElements
              },
              Some(r) => match l {
                  None => TypeInfo::NonNullableListNullableElements,
                  Some(l) => TypeInfo::NonNullableListNonNullableElements
              }
            }
        }
    }
};

ArgumentsDefinition: Vec<GraphQLArgument> = {
    "(" <i:InputValueDefinition+> ")" => {
        i
    }
};

// TODO: missing directives
InputValueDefinition: GraphQLArgument = {
    <d:Description*> <n:FieldName> ":" <t:FieldType> => {
        GraphQLArgument::new(d, n, t)
    }
};

Deprecated: bool = {
    "@deprecated" => true
};

DeprecatedReason: String = {
    "(reason: " <s:r#""[^"]*""#> ")" => {
      s[1..s.len()-1].to_string()
    }
};

Comma<T>: Vec<T> = {
    Comma1<T>? => <>.unwrap_or(vec![])
};

Comma1<T>: Vec<T> = {
    <t:T> => vec![t],
    <v:Comma<T>> "," <t:T> => {
        let mut v = v;
        v.push(t);
        v
    }
};

Pipe<T>: Vec<T> = {
    Pipe1<T>? => <>.unwrap_or(vec![])
};

Pipe1<T>: Vec<T> = {
    <t:T> => vec![t],
    <v:Pipe<T>> "|" <t:T> => {
        let mut v = v;
        v.push(t);
        v
    }
};

// NOTE: This is gross, can it be improved?
Name: String = r"[_A-Za-z][_0-9A-Za-z]*" => <>.to_owned();
FieldName: String = {
    r"[_A-Za-z][_0-9A-Za-z]*" => <>.to_owned(),
    "scalar"  => "scalar".to_owned(),
    "type"  => "type".to_owned(),
    "enum"  => "enum".to_owned(),
    "interface"  => "interface".to_owned(),
    "union"  => "union".to_owned(),
    "input"  => "input".to_owned(),
};

Description: String = <s:r"#\s*.+"> => s[1..s.len()].trim().to_owned();
